<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cesium Rocket Visualization: 3 Camera Modes + Distance Slider + 3D Distance Line</title>

  <!-- Cesium CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/cesium@1.104.0/Build/Cesium/Widgets/widgets.css"
    rel="stylesheet"
  />
  <style>
    /* Fullscreen Cesium Canvas */
    html, body {
      margin: 0; 
      padding: 0; 
      width: 100%; 
      height: 100%;
      overflow: hidden; 
      background: #000;
    }
    #cesiumContainer {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    /* Container for mode button + slider */
    #uiContainer {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 8px;
      border-radius: 5px;
      font-family: sans-serif;
    }
    #modeBtn {
      margin-bottom: 8px;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      color: white;
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 14px;
    }
    .sliderContainer {
      display: flex; 
      flex-direction: row; 
      align-items: center;
      gap: 5px;
      margin-bottom: 8px;
    }
    .sliderContainer label {
      font-size: 13px; 
    }
    .sliderContainer input[type="range"] {
      width: 130px;
    }

    /* Container for lat/lon input (line-drawing) */
    #locationForm {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 999;
      background: rgba(0,0,0,0.6);
      color: white;
      padding: 8px;
      border-radius: 5px;
      font-family: sans-serif;
    }
    #locationForm label {
      display: block;
      margin: 3px 0 2px;
      font-size: 13px;
    }
    #locationForm input {
      width: 80px;
      margin-right: 8px;
    }
    #drawLineBtn {
      margin-top: 8px;
      cursor: pointer;
      background: rgba(255,255,255,0.2);
      color: white;
      border: 1px solid #ccc;
      padding: 4px 8px;
      border-radius: 3px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- The Cesium globe container -->
  <div id="cesiumContainer"></div>

  <!-- Top-left: Mode button + distance slider -->
  <div id="uiContainer">
    <button id="modeBtn">Mode: LOCKED</button>
    <div class="sliderContainer">
      <label for="distanceSlider">Distance:</label>
      <input id="distanceSlider" type="range" min="100" max="20000" step="100" value="5000">
    </div>
  </div>

  <!-- Bottom-left: lat/lon input form for line drawing -->
  <div id="locationForm">
    <label>Your Latitude:</label>
    <input type="text" id="myLat" placeholder="e.g. 29.2108" />
    <label>Your Longitude:</label>
    <input type="text" id="myLon" placeholder="e.g. -81.0228" />
    <button id="drawLineBtn">Draw Line to Rocket</button>
  </div>

  <!-- Socket.IO (adjust path if needed) -->
  <script src="/socket.io/socket.io.js"></script>
  <!-- CesiumJS -->
  <script src="https://cdn.jsdelivr.net/npm/cesium@1.104.0/Build/Cesium/Cesium.js"></script>
  
  <script>
  /************************************************
   *  Basic Cesium Setup
   ************************************************/
   Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI5NDQyNDE4My1kNjkxLTQ0MDUtOWEyNC1mOTM5MTA3ZjNkNmYiLCJpZCI6MjY0Njk2LCJpYXQiOjE3MzUwNjk4OTZ9._NYeNPDjESMzfcYTEBkiR-nnPKCCDNYdt2skAjllwdM';

  const viewer = new Cesium.Viewer('cesiumContainer', {
    shouldAnimate: true,
    infoBox: false,
    selectionIndicator: false,
    timeline: false,
    animation: false,
    terrainProvider: new Cesium.EllipsoidTerrainProvider()
  });

  /************************************************
   *  Rocket Entity
   ************************************************/
  const rocketPosition = new Cesium.SampledPositionProperty();
  let rocketAltitude = 0;

  const rocketEntity = viewer.entities.add({
    name: 'Rocket',
    position: rocketPosition,
    orientation: new Cesium.VelocityOrientationProperty(rocketPosition),
    point: {
      pixelSize: 10,
      color: Cesium.Color.RED,
      outlineColor: Cesium.Color.WHITE,
      outlineWidth: 1
    },
    path: {
      show: true,
      leadTime: 0,
      trailTime: 999999,
      width: 3,
      material: Cesium.Color.BLUE
    }
  });

  // altitude label
  viewer.entities.add({
    position: rocketPosition,
    label: {
      text: new Cesium.CallbackProperty(() => {
        return `SPECTRE -> ${rocketAltitude.toFixed(0)} m`;
      }, false),
      font: '18px sans-serif',
      fillColor: Cesium.Color.BLACK,
      showBackground: true,
      backgroundColor: Cesium.Color.WHITE,
      pixelOffset: new Cesium.Cartesian2(110, 0),
      heightReference: Cesium.HeightReference.NONE
    }
  });

  // track last rocket positions for fallback
  const lastPositions = [];
  let firstUpdate = true;

  /************************************************
   *  Socket.IO for Real-time Data
   ************************************************/
  const socket = io(); // e.g. "http://localhost:3000"
  socket.on('gpsData', (data) => {
    const { lat, lon, altitude } = data;
    if (lat != null && lon != null && altitude != null) {
      rocketAltitude = altitude;

      const now = Cesium.JulianDate.now();
      const cartPos = Cesium.Cartesian3.fromDegrees(lon, lat, altitude);
      rocketPosition.addSample(now, cartPos);

      lastPositions.push({ time: now, pos: cartPos });
      if (lastPositions.length > 30) {
        lastPositions.shift();
      }

      // On first data, lock by default
      if (firstUpdate) {
        viewer.trackedEntity = rocketEntity;
        firstUpdate = false;
      }
    }
  });

  /************************************************
   *  3 Camera Modes: LOCKED, FREE, CIRCLE
   ************************************************/
  let modeBtn  = document.getElementById('modeBtn');
  let mode     = 'LOCKED'; 
  // possible values: "LOCKED", "FREE", "CIRCLE"

  function updateModeLabel() {
    modeBtn.innerText = `Mode: ${mode}`;
  }

  // Cycle modes on button click
  modeBtn.addEventListener('click', () => {
    if (mode === 'LOCKED') {
      mode = 'FREE';
    } else if (mode === 'FREE') {
      mode = 'CIRCLE';
    } else {
      mode = 'LOCKED';
    }
    applyCameraMode();
    updateModeLabel();
  });

  // Also let user press "M" to cycle
  window.addEventListener('keydown', (e)=>{
    if(e.key.toLowerCase()==='m'){
      if (mode === 'LOCKED') {
        mode = 'FREE';
      } else if (mode === 'FREE') {
        mode = 'CIRCLE';
      } else {
        mode = 'LOCKED';
      }
      applyCameraMode();
      updateModeLabel();
    }
  });

  function applyCameraMode() {
    if (mode === 'LOCKED') {
      // track rocket
      viewer.trackedEntity = rocketEntity;
    } else {
      viewer.trackedEntity = undefined;
    }
  }

  // For circle mode
  let circleHeading = 0; 
  const circlePitch = Cesium.Math.toRadians(-45);

  /************************************************
   *  Distance Slider for circle mode
   ************************************************/
  const distanceSlider = document.getElementById('distanceSlider');
  let circleDistance   = parseFloat(distanceSlider.value);

  distanceSlider.addEventListener('input', () => {
    circleDistance = parseFloat(distanceSlider.value);
  });

  // orbit logic in postRender if mode=CIRCLE
  viewer.scene.postRender.addEventListener(() => {
    if (mode !== 'CIRCLE') {
      return;
    }
    let rocketCartPos = rocketPosition.getValue(Cesium.JulianDate.now());
    if(!rocketCartPos && lastPositions.length>0){
      rocketCartPos = lastPositions[lastPositions.length-1].pos;
    }
    if(!rocketCartPos){
      return; // can't orbit if no rocket data
    }
    circleHeading += 0.002; 
    const headingPitchRange = new Cesium.HeadingPitchRange(circleHeading, circlePitch, circleDistance);
    viewer.scene.camera.lookAt(rocketCartPos, headingPitchRange);
  });

  /************************************************
   *   Draw a line from Ground Station to the rocket, continuously
   ************************************************/
  let myPos = null; // we'll store your location as a Cartesian3
  let myLocationEntity;
  let distanceLineEntity;
  let distanceLineLabelEntity;

  const drawLineBtn = document.getElementById('drawLineBtn');
  drawLineBtn.addEventListener('click', () => {
    const latStr = document.getElementById('myLat').value.trim();
    const lonStr = document.getElementById('myLon').value.trim();
    if(!latStr || !lonStr) {
      alert('Please enter your latitude and longitude!');
      return;
    }
    // parse as float
    const myLat = parseFloat(latStr);
    const myLon = parseFloat(lonStr);
    if(isNaN(myLat) || isNaN(myLon)) {
      alert('Invalid lat/lon. Must be numeric, e.g. 29.2108, -81.0228');
      return;
    }

    // create or update "my location" entity at altitude=0
    myPos = Cesium.Cartesian3.fromDegrees(myLon, myLat, 0);

    if(!myLocationEntity) {
      myLocationEntity = viewer.entities.add({
        name: 'My Location',
        position: myPos,
        point: {
          pixelSize: 8,
          color: Cesium.Color.GREEN,
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 1
        },
        label: {
          text: 'Ground Station',
          font: '18px sans-serif',
          fillColor: Cesium.Color.BLACK,
          showBackground: true,
          backgroundColor: Cesium.Color.WHITE,
          pixelOffset: new Cesium.Cartesian2(110, 0),
          heightReference: Cesium.HeightReference.NONE
        }
      });
    } else {
      myLocationEntity.position = myPos;
    }

    // If line + label exist, remove them so we can re-create
    if(distanceLineEntity) {
      viewer.entities.remove(distanceLineEntity);
    }
    if(distanceLineLabelEntity) {
      viewer.entities.remove(distanceLineLabelEntity);
    }

    // A polyline with dynamic positions
    distanceLineEntity = viewer.entities.add({
      name: 'MyToRocketLine',
      polyline: {
        positions: new Cesium.CallbackProperty(()=>{
          // Each frame, get rocket's position
          let rocketCartPos = rocketPosition.getValue(Cesium.JulianDate.now());
          if(!rocketCartPos && lastPositions.length>0){
            rocketCartPos = lastPositions[lastPositions.length-1].pos;
          }
          if(!rocketCartPos || !myPos) {
            return [];
          }
          return [myPos, rocketCartPos];
        }, false),
        width: 3,
        material: Cesium.Color.YELLOW
      }
    });

    // A label with dynamic text for 3D distance
    distanceLineLabelEntity = viewer.entities.add({
      position: new Cesium.CallbackProperty(()=>{
        // midpoint each frame
        let rocketCartPos = rocketPosition.getValue(Cesium.JulianDate.now());
        if(!rocketCartPos && lastPositions.length>0){
          rocketCartPos = lastPositions[lastPositions.length-1].pos;
        }
        if(!rocketCartPos || !myPos) {
          return Cesium.Cartesian3.ZERO;
        }
        return Cesium.Cartesian3.midpoint(myPos, rocketCartPos, new Cesium.Cartesian3());
      }, false),
      label: {
        text: new Cesium.CallbackProperty(()=>{
          // 3D distance
          let rocketCartPos = rocketPosition.getValue(Cesium.JulianDate.now());
          if(!rocketCartPos && lastPositions.length>0){
            rocketCartPos = lastPositions[lastPositions.length-1].pos;
          }
          if(!rocketCartPos || !myPos) {
            return 'No Data';
          }
          const dist3D = Cesium.Cartesian3.distance(myPos, rocketCartPos);
          const distKm = dist3D / 1000.0;
          return `${distKm.toFixed(2)} km`;
        }, false),
        font: '18px sans-serif',
        fillColor: Cesium.Color.BLACK,
        showBackground: true,
        backgroundColor: Cesium.Color.WHITE,
        pixelOffset: new Cesium.Cartesian2(0, 20),
        heightReference: Cesium.HeightReference.NONE
      }
    });

    // Fly so we can see the line
    viewer.flyTo(distanceLineEntity);
  });

  console.log('Cesium with 3 camera modes (locked, free, circle) + distance slider + lat/lon line code loaded.');
  </script>
</body>
</html>
