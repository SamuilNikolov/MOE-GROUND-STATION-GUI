<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live GPS, Velocity, Altitude, Temperature, and Acceleration Vectors</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Shared CSS -->
  <link rel="stylesheet" href="./shared.css">
</head>
<body>
  <!-- Left side: Map -->
  <div id="map"></div>
     
  <!-- Right side: Telemetry bars & 3D acceleration visualization -->
  <div id="bars-container">
    <div id="logging-status">
      Logging: NOT INITIALIZED
    </div>
    <div id="bars-row" style="display: flex; flex-direction: row; justify-content: space-between;">
      
      <!-- Acceleration Vectors 3D visualization -->
      <div class="bar-container gyro">
        <div class="gyro-inner">
          <canvas id="orientationCanvas"></canvas>
        </div>
        <div class="bar-display">Acceleration & Orientation</div>
      </div>

      <!-- Velocity bar -->
      <div class="bar-container">
        <div class="velocity-bar" id="velocity-bar">
          <div class="rocket" id="rocket"></div>
        </div>
        <div class="bar-display" id="velocity-display">Velocity: 0 km/h</div>
      </div>

      <!-- Altitude bar -->
      <div class="bar-container">
        <div class="altitude-bar" id="altitude-bar">
          <div class="altitude-fill" id="altitude-fill"></div>
        </div>
        <div class="bar-display" id="altitude-display">Altitude: 0 m</div>
      </div>

      <!-- Temperature bar -->
      <div class="bar-container">
        <div class="temperature-bar" id="temperature-bar">
          <div class="temperature-fill" id="temperature-fill"></div>
        </div>
        <div class="bar-display" id="temperature-display">Temp: 0 °C</div>
      </div>
    </div>

    <!-- Bottom section: Acceleration Chart -->
    <div id="acc-container">
      <canvas id="accChart"></canvas>
    </div>
    
    <!-- Button for enabling audio features (Beep only, no speech) -->
    <button id="enable-voice-btn">Enable Audio</button>
  </div>

  <!-- External Scripts -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>

  <script>
  /************************************************
   *        Configuration & Globals
   ************************************************/
  const maxVelocity         = 100;
  const maxAltitude         = 3000;
  const maxTemperature      = 50;
  const velocityInterval    = 10;
  const altitudeInterval    = 100;
  const temperatureInterval = 5;
  const maxPoints           = 50;  // Max data points in Chart.js
  const maxCoords           = 50;  // Max GPS coords for polyline path

  // Telemetry sample count (for beeps every 2 samples)
  let sampleCount = 0;

  // Apogee detection
  const apogeeDetectN = 10;   // Consecutive descending
  let allAltitudesArray = []; // Store all altitudes for median
  let descentHistory    = []; // Last 'apogeeDetectN' altitudes
  let apogeeAnnounced   = false;
  let maxAltitudeReached= 0;  // For bar display

  // Track last altitude
  let lastAltitude = 0;

  // DOM references
  const rocket             = document.getElementById('rocket');
  const altitudeFill       = document.getElementById('altitude-fill');
  const velocityDisplay    = document.getElementById('velocity-display');
  const altitudeDisplay    = document.getElementById('altitude-display');
  const temperatureFill    = document.getElementById('temperature-fill');
  const temperatureDisplay = document.getElementById('temperature-display');
  const voiceBtn           = document.getElementById('enable-voice-btn');
  const loggingStatus      = document.getElementById('logging-status');

  /************************************************
   *       Audio / Beep Setup
   ************************************************/
  let beepEnabled = false;
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let selectedVoice = null;  // the chosen voice

  voiceBtn.addEventListener('click', () => {
    beepEnabled = true;
    console.log('Audio beeps enabled by user.');
    audioCtx.resume();
    window.speechSynthesis.getVoices();
  });
  window.speechSynthesis.onvoiceschanged = () => {
    const voices = window.speechSynthesis.getVoices();
    // pick an english female voice if possible
    selectedVoice = voices.find(v => 
      v.lang.toLowerCase().includes('en') && v.name.toLowerCase().includes('female')
    ) || voices.find(v => v.lang.toLowerCase().includes('en')) || null;
  };

  // Generic beep function
  function beep(duration=100, frequency=880, volume=1, type='sine'){
    if(!beepEnabled) return;
    const oscillator = audioCtx.createOscillator();
    const gainNode   = audioCtx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
    oscillator.start();
    setTimeout(()=>oscillator.stop(), duration);
  }
  function speakMessage(msg){
    if(!beepEnabled) return;
    const utter = new SpeechSynthesisUtterance(msg);
    if(selectedVoice) utter.voice=selectedVoice;
    utter.pitch=1;
    utter.rate =1.0;
    window.speechSynthesis.speak(utter);
  }
  /************************************************
   *       Create Ticks on Bars
   ************************************************/
  function createTicks(barId, maxValue, interval){
    const bar = document.getElementById(barId);
    const numTicks = Math.floor(maxValue/interval);
    bar.querySelectorAll('.tick-label').forEach(t=>t.remove());
    for(let i=0; i<=numTicks; i++){
      const position = (i/numTicks)*100;
      const label = document.createElement('div');
      label.className = 'tick-label';
      label.style.bottom = position + '%';
      label.innerText = (i*interval).toString();
      bar.appendChild(label);
    }
  }
  createTicks('velocity-bar', maxVelocity, velocityInterval);
  createTicks('altitude-bar', maxAltitude, altitudeInterval);
  createTicks('temperature-bar', maxTemperature, temperatureInterval);

  /************************************************
   *       Leaflet Map
   ************************************************/
  const map = L.map('map').setView([29.210815, -81.022835], 13);
  L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    maxZoom: 21,
    attribution: 'Tiles © Esri ...'
  }).addTo(map);

  const marker = L.marker([29.210815, -81.022835]).addTo(map);
  const recentCoordinates = [];
  const polyline = L.polyline([], { color: 'red' }).addTo(map);

  /************************************************
   *       Socket.IO for Real-time Data
   ************************************************/
  const socket = io();

  socket.on('logInfo', info => {
    loggingStatus.innerText = `Logging to file: ${info.fileName} | ${info.lines} lines.`;
  });

  socket.on('gpsData', data => {
    const {
      lat, lon, velocity, altitude, temperature,
      xAcc, yAcc, zAcc, roll, pitch, yaw
    } = data;

    // Update map & path
    if(lat!==undefined && lon!==undefined){
      marker.setLatLng([lat, lon]);
      map.panTo([lat, lon]);
      recentCoordinates.push([lat, lon]);
      if(recentCoordinates.length>maxCoords) recentCoordinates.shift();
      polyline.setLatLngs(recentCoordinates);
    }

    // Update bars
    if(velocity!==undefined) updateVelocity(velocity);
    if(altitude!==undefined){
      updateAltitude(altitude);
      checkApogee(altitude);
      lastAltitude = altitude;
    }
    if(temperature!==undefined) updateTemperature(temperature);

    // Acceleration data => chart & 3D arrows
    if(xAcc!==undefined && yAcc!==undefined && zAcc!==undefined){
      sampleCount++;
      updateAccelerationChart(xAcc,yAcc,zAcc);
      updateAccelerationArrows(xAcc,yAcc,zAcc);

      // Telemetry beep every 2 samples
      if(sampleCount % 2 === 0){
        beep(100, altitude/10+300, 0.5, 'sine');
      }
    }

    // Orientation
    if(roll!==undefined && pitch!==undefined && yaw!==undefined){
      targetRoll  = roll;
      targetPitch = pitch;
      targetYaw   = yaw;
    }
  });

  /************************************************
   *     Bars Update
   ************************************************/
  function updateVelocity(velocity){
    const norm = Math.min(velocity/maxVelocity,1);
    rocket.style.height = (norm*100)+'%';
    velocityDisplay.innerText = 'Velocity: ' + velocity + ' km/h';

    document.querySelectorAll('#velocity-bar .tick-label').forEach(label=>{
      const val = parseInt(label.innerText,10);
      label.style.color = (velocity>=val)?'lime':'white';
    });
  }

  function updateAltitude(alt){
    const norm = Math.min(alt/maxAltitude,1);
    altitudeFill.style.height = (norm*100)+'%';
    altitudeDisplay.innerText='Altitude: '+Math.round(alt)+' m';

    document.querySelectorAll('#altitude-bar .tick-label').forEach(label=>{
      const val = parseInt(label.innerText,10);
      label.style.color = (alt>=val)?'lime':'white';
    });
  }

  function updateTemperature(temp){
    const norm = Math.min(temp/maxTemperature,1);
    temperatureFill.style.height=(norm*100)+'%';
    temperatureDisplay.innerText='Temp: '+temp+' °C';

    document.querySelectorAll('#temperature-bar .tick-label').forEach(label=>{
      const val = parseInt(label.innerText,10);
      label.style.color=(temp>=val)?'lime':'white';
    });
  }

  /************************************************
   *     Acceleration Chart
   ************************************************/
  const ctx = document.getElementById('accChart').getContext('2d');
  const accChart = new Chart(ctx, {
    type:'line',
    data:{
      labels:[],
      datasets:[
        { label:'X Acc', data:[], borderColor:'red',   borderWidth:1, fill:false, tension:0 },
        { label:'Y Acc', data:[], borderColor:'green', borderWidth:1, fill:false, tension:0 },
        { label:'Z Acc', data:[], borderColor:'blue',  borderWidth:1, fill:false, tension:0 }
      ]
    },
    options:{
      responsive:false,
      maintainAspectRatio:false,
      scales:{
        x:{display:false},
        y:{
          min:-10,
          max:10,
          title:{display:true, text:'Acceleration (g)'}
        }
      },
      animation:false
    }
  });

  function updateAccelerationChart(xAcc,yAcc,zAcc){
    accChart.data.labels.push(sampleCount);
    accChart.data.datasets[0].data.push(xAcc);
    accChart.data.datasets[1].data.push(yAcc);
    accChart.data.datasets[2].data.push(zAcc);

    while(accChart.data.labels.length>maxPoints){
      accChart.data.labels.shift();
      accChart.data.datasets.forEach(ds=>ds.data.shift());
    }
    accChart.update();
  }

  /************************************************
   *   Apogee Detection: 10 Descending + Top 50 Median
   ************************************************/
  function checkApogee(currentAlt){
    // Track every altitude
    allAltitudesArray.push(currentAlt);

    // Keep last 10 alt for consecutive descending check
    descentHistory.push(currentAlt);
    if(descentHistory.length>apogeeDetectN){
      descentHistory.shift();
    }

    // Track the max altitude for bars
    if(currentAlt>maxAltitudeReached){
      maxAltitudeReached=currentAlt;
    }

    // Check if last N are strictly descending
    if(!apogeeAnnounced && descentHistory.length===apogeeDetectN){
      let strictlyDescending=true;
      for(let i=0;i<descentHistory.length-1;i++){
        if(descentHistory[i]<=descentHistory[i+1]){
          strictlyDescending=false;
          break;
        }
      }
      // Confirm apogee
      if(strictlyDescending){
        const apogeeMedian=computeMedianOfTop50(allAltitudesArray,50);
        // Apogee beep
        beep(200,880,1,'square');
        speakMessage(`Apogee reached at ${Math.round(apogeeMedian)} meters`);
        apogeeAnnounced=true;
      }
    }
  }

  function computeMedianOfTop50(altArray, topN=50){
    // Sort all altitudes descending
    const sortedDesc=[...altArray].sort((a,b)=>b-a);
    // take topN
    const top=sortedDesc.slice(0,topN);
    // sort ascending for median
    top.sort((a,b)=>a-b);

    const n=top.length;
    if(n===0) return 0;

    const mid=Math.floor(n/2);
    if(n%2===1){
      return top[mid];
    } else {
      return (top[mid-1]+top[mid])/2;
    }
  }

  /************************************************
   *   Three.js Orientation Setup
   ************************************************/
  const orientationCanvas=document.getElementById('orientationCanvas');
  const renderer=new THREE.WebGLRenderer({canvas:orientationCanvas,antialias:true,alpha:true});
  renderer.setSize(orientationCanvas.offsetWidth, orientationCanvas.offsetHeight);

  const scene=new THREE.Scene();
  scene.background=new THREE.Color(0x000000);

  const camera=new THREE.PerspectiveCamera(60, orientationCanvas.clientWidth/orientationCanvas.clientHeight, 0.1, 1000);
  camera.position.set(0,0,6);

  // lighting
  const ambient=new THREE.AmbientLight(0xffffff,0.4);
  scene.add(ambient);
  const directional=new THREE.DirectionalLight(0xffffff,1);
  directional.position.set(0,1000,7);
  scene.add(directional);

  // grid
  const planeSize=20;
  const gridHelper=new THREE.GridHelper(planeSize,20,0x00ff00,0x00ff00);
  gridHelper.position.y=-2;
  scene.add(gridHelper);

  // arrows
  const arrowX=new THREE.ArrowHelper(new THREE.Vector3(1,0,0),new THREE.Vector3(0,0,0),0,0xff0000);
  const arrowY=new THREE.ArrowHelper(new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,0),0,0x00ff00);
  const arrowZ=new THREE.ArrowHelper(new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,0),0,0x0000ff);
  scene.add(arrowX,arrowY,arrowZ);

  // axis labels
  const labelX=createTextSprite("X Acc");
  const labelY=createTextSprite("Y Acc");
  const labelZ=createTextSprite("Z Acc");
  scene.add(labelX,labelY,labelZ);

  // rocket group
  const rocketGroup=new THREE.Group();
  const rocketMat=new THREE.MeshPhongMaterial({color:0xffffff});
  
  const bodyGeo=new THREE.CylinderGeometry(0.3,0.3,2,16);
  const body=new THREE.Mesh(bodyGeo,rocketMat);
  rocketGroup.add(body);

  const noseGeo=new THREE.ConeGeometry(0.3,0.6,16);
  const nose=new THREE.Mesh(noseGeo,rocketMat);
  nose.position.y=1.3;
  rocketGroup.add(nose);

  // fins
  const finMat=new THREE.MeshPhongMaterial({color:0x00ff00});
  const finGeo=new THREE.BoxGeometry(0.05,0.5,0.3);
  for(let i=0; i<4; i++){
    const fin=new THREE.Mesh(finGeo,finMat);
    fin.position.y=-0.5;
    fin.position.x=0.25*Math.cos((Math.PI/2)*i);
    fin.position.z=0.25*Math.sin((Math.PI/2)*i);
    rocketGroup.add(fin);
  }
  rocketGroup.position.y=0;
  scene.add(rocketGroup);

  // Text sprite helpers
  function createTextSprite(message){
    const cvs=document.createElement('canvas');
    const ctx2d=cvs.getContext('2d');
    ctx2d.font='24px Arial';
    ctx2d.fillStyle='white';
    ctx2d.fillText(message,10,30);
    const tex=new THREE.CanvasTexture(cvs);
    const sprMat=new THREE.SpriteMaterial({map:tex});
    const sprite=new THREE.Sprite(sprMat);
    sprite.scale.set(1.5,0.75,1);
    return sprite;
  }

  function createLabelTexture(text){
    const c=document.createElement('canvas');
    const ctx2d=c.getContext('2d');
    ctx2d.font='24px Arial';
    ctx2d.fillStyle='white';
    ctx2d.fillText(text,10,30);
    return new THREE.CanvasTexture(c);
  }

  // update arrows
  function updateAccelerationArrows(xAcc,yAcc,zAcc){
    const scaleFactor=0.25;

    const xDir=(xAcc>=0)?1:-1;
    arrowX.setDirection(new THREE.Vector3(xDir,0,0).normalize());
    arrowX.setLength(Math.abs(xAcc)*scaleFactor,0.08,0.08);
    labelX.material.map.dispose();
    labelX.material.map=createLabelTexture(`X: ${xAcc.toFixed(2)}g`);
    labelX.position.set(xDir*Math.abs(xAcc)*scaleFactor+0.3*xDir,0,0);

    const yDir=(yAcc>=0)?1:-1;
    arrowY.setDirection(new THREE.Vector3(0,yDir,0).normalize());
    arrowY.setLength(Math.abs(yAcc)*scaleFactor,0.08,0.08);
    labelY.material.map.dispose();
    labelY.material.map=createLabelTexture(`Y: ${yAcc.toFixed(2)}g`);
    labelY.position.set(0,yDir*Math.abs(yAcc)*scaleFactor+0.3*yDir,0);

    const zDir=(zAcc>=0)?1:-1;
    arrowZ.setDirection(new THREE.Vector3(0,0,zDir).normalize());
    arrowZ.setLength(Math.abs(zAcc)*scaleFactor,0.08,0.08);
    labelZ.material.map.dispose();
    labelZ.material.map=createLabelTexture(`Z: ${zAcc.toFixed(2)}g`);
    labelZ.position.set(0,0,zDir*Math.abs(zAcc)*scaleFactor+0.3*zDir);
  }

  // orientation
  let currentRoll=0, currentPitch=0, currentYaw=0;
  let targetRoll=0, targetPitch=0, targetYaw=0;
  const orientationLerp=1; // instant

  const orientationRenderer=new THREE.WebGLRenderer({canvas:orientationCanvas,antialias:true,alpha:true});
  orientationRenderer.setSize(orientationCanvas.offsetWidth,orientationCanvas.offsetHeight);

  const scene3D=new THREE.Scene();
  scene3D.background=new THREE.Color(0x000000);

  camera.position.set(0,0,6);

  // lighting in 3D
  scene3D.add(ambient);
  directional.position.set(0,1000,7);
  scene3D.add(directional);

  // add grid
  scene3D.add(gridHelper,arrowX,arrowY,arrowZ,labelX,labelY,labelZ,rocketGroup);

  function animate3D(){
    requestAnimationFrame(animate3D);
    // rotate rocket
    currentRoll += orientationLerp*((targetRoll*Math.PI/180)-currentRoll);
    currentPitch+=orientationLerp*((targetPitch*Math.PI/180)-currentPitch);
    currentYaw  +=orientationLerp*((targetYaw*Math.PI/180)-currentYaw);

    rocketGroup.rotation.set(currentPitch,currentYaw,currentRoll);

    orientationRenderer.render(scene3D,camera);
  }
  animate3D();
  </script>
</body>
</html>
